<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒã‚¤ã‚¹ãƒ»ãƒˆãƒ©ãƒƒã‚«ãƒ¼</title>

  <!-- ----------------------------  CSS  ---------------------------- -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
      :root {
          --primary-color-start: #667eea;
          --primary-color-end: #764ba2;
          --secondary-color-start: #48bb78;
          --secondary-color-end: #38a169;
          --header-color-start: #4facfe;
          --header-color-end: #00f2fe;
          --bg-light: #f8f9ff;
          --border-light: #e3e8ff;
          --text-dark: #2d3748;
          --text-light: #fff;
      }
      *{margin:0;padding:0;box-sizing:border-box;}
      body{
          font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';
          background:linear-gradient(135deg, var(--primary-color-start) 0%, var(--primary-color-end) 100%);
          min-height:100vh;padding:1rem;
      }
      .container{
          max-width:900px;margin:0 auto;background:var(--text-light);border-radius:15px;
          box-shadow:0 20px 40px rgba(0,0,0,.1);overflow:hidden;
      }
      .header{
          background:linear-gradient(135deg, var(--header-color-start) 0%, var(--header-color-end) 100%);
          color:var(--text-light);padding:30px;text-align:center;
      }
      .header h1{font-size:2.2rem;margin-bottom:10px;}
      .content{padding:20px;}
      
      #map {
          width: 100%;
          height: 45vh;
          border-radius: 12px;
          margin-bottom: 20px;
          border: 3px solid var(--border-light);
          box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      }
      
      .ai-section {
          background:linear-gradient(135deg,#ffecd2 0%,#fcb69f 100%);
          border-radius:12px;padding:25px;margin-bottom:20px;border-left:5px solid #ed8936;
      }
      .ai-section h3 { color:#744210; margin-bottom:15px; display:flex; align-items:center; font-size: 1.5rem; }
      .ai-section h3::before { content:"ğŸ¤–"; margin-right:10px; }
      #aiContent {
          background-color: rgba(255,255,255,0.5);
          padding: 15px;
          border-radius: 8px;
          min-height: 50px;
          color: #5c4033;
          line-height: 1.6;
      }

      .controls-panel {
          background: var(--bg-light);
          padding: 15px;
          border-radius: 12px;
          margin-bottom: 20px;
          text-align: center;
      }

      .btn{
          background:linear-gradient(135deg, var(--primary-color-start) 0%, var(--primary-color-end) 100%);
          color:var(--text-light);border:none;padding:10px 20px;border-radius:8px;
          cursor:pointer;font-size:.9rem;font-weight:600;transition:.3s;margin:5px;
      }
      .btn:hover{transform:translateY(-2px);box-shadow:0 5px 15px rgba(0,0,0,.2);}
      .btn:disabled{background: #ccc; cursor: not-allowed; transform: none; box-shadow: none;}
      .btn.secondary{background:linear-gradient(135deg, var(--secondary-color-start) 0%, var(--secondary-color-end) 100%);}
      .btn.danger{background:linear-gradient(135deg,#f56565 0%,#e53e3e 100%);}
      
      .feature-grid{
          display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));
          gap:20px;
      }
      .feature-card{
          background:var(--bg-light);border:2px solid var(--border-light);border-radius:12px;
          padding:25px;transition:.3s;
      }
      .feature-card h3{color:#4c51bf;margin-bottom:15px;font-size:1.3rem;}
      
      .status{padding:15px;border-radius:8px;margin:15px 0;font-weight:500;}
      .status.info{background:#bee3f8;color:#2c5282;}
      .status.error{background:#fed7d7;color:#742a2a;}
      .status.success{background:#c6f6d5;color:#22543d;}

  </style>
</head>
<body>
  <div class="container">
      <div class="header">
          <h1>ğŸ“‰ ã‚¹ãƒãƒ¼ãƒˆãƒ‘ã‚¹ãƒ»ãƒˆãƒ©ãƒƒã‚«ãƒ¼</h1>
          <p>AIé§†å‹•ã®ãƒ‡ãƒã‚¤ã‚¹ç™ºè¦‹ã‚·ã‚¹ãƒ†ãƒ </p>
      </div>

      <div class="content">
          <div id="map"></div>

          <div class="controls-panel">
              <div id="bluetoothConnectUI">
                  <button class="btn" onclick="connectBluetoothDevice()">Bluetoothãƒ‡ãƒã‚¤ã‚¹æ¥ç¶š</button>
              </div>
              <div id="permissionRequestUI" style="display: none;">
                  <p style="margin-bottom: 10px;">ã‚ãªãŸã®çµŒè·¯ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã«ã€ãƒ‡ãƒã‚¤ã‚¹ã®ã‚»ãƒ³ã‚µãƒ¼ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™ã€‚</p>
                  <button class="btn secondary" style="font-size: 1.1rem; padding: 12px 28px;" onclick="requestPermissionsAndStart()">è¨±å¯ã—ã¦é–‹å§‹</button>
              </div>
              <div id="mainControls" style="display: none;">
                  <button class="btn danger" onclick="stopSensing()">è¨ˆæ¸¬åœæ­¢</button>
                  <button class="btn" onclick="exportCSV()">CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                  <button class="btn secondary" onclick="exportJSON()">JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
              </div>
              <div id="deviceNameDisplay" style="margin: 10px 0; font-weight: bold;"></div>
              <button class="btn danger" onclick="resetHistory()">å±¥æ­´ãƒªã‚»ãƒƒãƒˆ</button>
          </div>
          
          <!-- ãƒãƒ«ãƒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šä¿¡ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
          <div class="multi-client-section" style="margin: 24px 0; padding: 18px; background: #f8f9ff; border-radius: 12px; border: 2px solid #e3e8ff; box-shadow: 0 2px 8px rgba(0,0,0,0.03);">
              <h3 style="margin-bottom: 12px; color: #667eea;">ãƒãƒ«ãƒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šä¿¡</h3>
              <button class="btn danger" style="margin-right: 12px;" onclick="broadcastLostDevice()">ãªãã—ã¾ã—ãŸï¼ˆå‘¨å›²ã«é€šçŸ¥ï¼‰</button>
              <button class="btn" onclick="assistSearch()">æ‰‹ä¼ï¼ˆå‘¨å›²ã‚’ã‚¹ã‚­ãƒ£ãƒ³ï¼‰</button>
              <button class="btn" onclick="manualHelpReport()">æ‰‹ä¼ï¼ˆä¼è¨€ï¼‰</button>
          </div>

          <div class="ai-section">
              <h3>AIåˆ†æãƒ»ææ¡ˆã‚·ã‚¹ãƒ†ãƒ </h3>
              <div id="aiContent">ååˆ†ãªãƒ‡ãƒ¼ã‚¿ãŒåé›†ã•ã‚Œã‚‹ã¨ã€AIã®åˆ†æã¨ææ¡ˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>
              <div style="text-align: center; margin-top: 15px;">
                  <button class="btn" id="aiAnalysisBtn" onclick="getAIAnalysis()">AIåˆ†æã‚’å®Ÿè¡Œ</button>
                  <button class="btn secondary" id="aiSuggestBtn" onclick="getSearchSuggestions()">æ¢ç´¢ææ¡ˆã‚’å–å¾—</button>
              </div>
          </div>
          
          <div id="status" class="status info" style="display:none;"></div>

          <div class="feature-grid">
              <div class="feature-card">
                  <h3>ğŸ§  ãƒ‡ãƒ¼ã‚¿è©³ç´°</h3>
                  <p>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã¨èªè­˜æƒ…å ±ã‚’è¡¨ç¤º</p>
                  <div id="accelerometer">åŠ é€Ÿåº¦: æœªæ¤œå‡º</div>
                  <div id="location" style="margin-top: 5px;">ä½ç½®: æœªæ¤œå‡º</div>
                  <div id="movementPattern" style="margin-top: 5px;">ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³: ä¸æ˜</div>
              </div>

              <div class="feature-card">
                  <h3>ğŸŒ æ¥ç¶šæƒ…å ±</h3>
                  <p>ã‚»ãƒƒã‚·ãƒ§ãƒ³è­˜åˆ¥æƒ…å ±</p>
                  <div id="userIdDisplay" style="margin-top: 5px;">ãƒ¦ãƒ¼ã‚¶ãƒ¼ID: æœªç”Ÿæˆ</div>
                  <div id="recordCount" style="margin-top: 5px;">ãƒ­ãƒ¼ã‚«ãƒ«è¨˜éŒ²æ•°: 0</div>
              </div>
          </div>
      </div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
    let sensorData = { accelerometer:{x:0,y:0,z:0}, location:{lat:0,lng:0,accuracy:0} };
    let sensorHistory = [];
    const HISTORY_LIMIT = 100;
    let sensingActive = false;
    let geoWatchId = null;
    let userId = null;
    let connectedDeviceName = null;
    let deviceId = null;
    
    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
    const BACKEND_URL = 'https://pankuzutracker-test.onrender.com';

    // --- åœ°å›³å¤‰æ•° ---
    let map, markerGroup;

    function initMap() {
        map = L.map('map').setView([35.681236, 139.767125], 16); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: æ±äº¬é§…
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);
        markerGroup = L.layerGroup().addTo(map);
        updateMapMarkers();
        fetchAndDisplayBroadcasts(); // å–å›æ‰€æœ‰å¹¿æ’­ä¿¡æ¯å¹¶æ˜¾ç¤ºåœ¨åœ°å›¾
        setInterval(fetchAndDisplayBroadcasts, 10000); // å®šæ—¶åˆ·æ–°å¹¿æ’­ç‚¹
    }

    function updateMapMarkers() {
        if (!markerGroup) return;
        markerGroup.clearLayers();
        if (sensorHistory.length === 0) return;
        const customIcon = L.icon({
            iconUrl: '/src/pan.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32]
        });
        sensorHistory.forEach(record => {
            if (record.loc && record.loc.lat && record.loc.lng) {
                const lat = parseFloat(record.loc.lat);
                const lng = parseFloat(record.loc.lng);
                L.marker([lat, lng], {icon: customIcon}).addTo(markerGroup)
                    .bindPopup(`æ™‚é–“: ${new Date(record.ts).toLocaleTimeString()}<br>çŠ¶æ…‹: ${classifyMovement(record.accel).status}`);
            }
        });
        const last = sensorHistory[sensorHistory.length-1];
        if (last && last.loc && last.loc.lat && last.loc.lng) {
            map.setView([parseFloat(last.loc.lat), parseFloat(last.loc.lng)], 18);
        }
    }

    /* ---------- ã‚³ã‚¢ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---------- */
    function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('status');
        statusEl.textContent = message;
        statusEl.className = `status ${type}`;
        statusEl.style.display = 'block';
        setTimeout(() => { statusEl.style.display = 'none'; }, 5000);
    }
    
    function getOrCreateUserId() {
        let storedUserId = localStorage.getItem('deviceTrackerUserId');
        if (!storedUserId) {
            storedUserId = crypto.randomUUID();
            localStorage.setItem('deviceTrackerUserId', storedUserId);
        }
        return storedUserId;
    }

    function getOrCreateDeviceId() {
        let storedDeviceId = localStorage.getItem('deviceTrackerDeviceId');
        if (!storedDeviceId) {
            storedDeviceId = crypto.randomUUID();
            localStorage.setItem('deviceTrackerDeviceId', storedDeviceId);
        }
        return storedDeviceId;
    }

    function initializeSystem() {
        showStatus('ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ã„ã¾ã™...', 'info');
        document.getElementById('permissionRequestUI').style.display = 'none';
        document.getElementById('mainControls').style.display = 'block';
        userId = getOrCreateUserId();
        deviceId = getOrCreateDeviceId();
        document.getElementById('userIdDisplay').textContent = `ãƒ¦ãƒ¼ã‚¶ãƒ¼ID: ${userId}`;
        if (document.getElementById('deviceIdDisplay')) {
            document.getElementById('deviceIdDisplay').textContent = `ãƒ‡ãƒã‚¤ã‚¹ID: ${deviceId}`;
        }
        startSensing();
    }

    window.requestPermissionsAndStart = async function() {
        let motionGranted = true;
        try {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                const permission = await DeviceMotionEvent.requestPermission();
                motionGranted = (permission === 'granted');
            }
        } catch (error) {
            motionGranted = false;
            showStatus('ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ãƒ³ã‚µãƒ¼ã®æ¨©é™ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
        }
        if (motionGranted && navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    showStatus('æ¨©é™ãŒæ‰¿èªã•ã‚Œã¾ã—ãŸï¼', 'success');
                    localStorage.setItem('sensorPermissionGranted', 'true');
                    initializeSystem();
                    handleLocation(position); 
                },
                (error) => {
                    showStatus('ä½ç½®æƒ…å ±ã®æ¨©é™ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã¾ã™ã€‚', 'error');
                    if (motionGranted) {
                        localStorage.setItem('sensorPermissionGranted', 'true');
                        initializeSystem();
                    }
                }
            );
        } else {
            showStatus('ã‚»ãƒ³ã‚µãƒ¼ã®æ¨©é™ãŒæ‹’å¦ã•ã‚ŒãŸã‹ã€åˆ©ç”¨ä¸å¯èƒ½ã§ã™ã€‚', 'error');
        }
    }

    function startSensing() {
        if (sensingActive) return;
        sensingActive = true;
        showStatus('è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'success');
        window.addEventListener('devicemotion', handleMotion);
        if (navigator.geolocation) {
            geoWatchId = navigator.geolocation.watchPosition(handleLocation, handleLocationError, { enableHighAccuracy: true });
        }
    }

    window.stopSensing = function() {
        if (!sensingActive) { showStatus('è¨ˆæ¸¬ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info'); return; }
        sensingActive = false;
        window.removeEventListener('devicemotion', handleMotion);
        if (geoWatchId !== null) navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
        showStatus('è¨ˆæ¸¬ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'success');
        connectedDeviceName = null;
        updateDeviceNameDisplay();
    }

    function handleMotion(e) {
        if (!sensingActive) return;
        sensorData.accelerometer = { x: e.accelerationIncludingGravity.x?.toFixed(2) || 0, y: e.accelerationIncludingGravity.y?.toFixed(2) || 0, z: e.accelerationIncludingGravity.z?.toFixed(2) || 0 };
        document.getElementById('accelerometer').innerHTML = `åŠ é€Ÿåº¦: X:${sensorData.accelerometer.x} Y:${sensorData.accelerometer.y} Z:${sensorData.accelerometer.z}`;
        pushRecord();
    }

    function handleLocation(pos) {
        if (!sensingActive) return;
        sensorData.location = { lat: pos.coords.latitude.toFixed(6), lng: pos.coords.longitude.toFixed(6), accuracy: Math.round(pos.coords.accuracy) };
        document.getElementById('location').innerHTML = `ä½ç½®: ${sensorData.location.lat}, ${sensorData.location.lng} (ç²¾åº¦: ${sensorData.location.accuracy}m)`;
        pushRecord();
    }
    function handleLocationError(err) { showStatus(`ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'error'); }

    function pushRecord() {
        if (!sensingActive) return;
        // â˜…â˜…â˜… å¤‰æ›´ç‚¹: bluetoothConnected ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ  â˜…â˜…â˜…
        const rec = { 
            ts: new Date().toISOString(), 
            accel: { ...sensorData.accelerometer }, 
            loc: { ...sensorData.location },
            bluetoothConnected: !!connectedDeviceName // true or false
        };
        sensorHistory.push(rec);
        if (sensorHistory.length > HISTORY_LIMIT) sensorHistory.shift();
        localStorage.setItem('sensorHistory', JSON.stringify(sensorHistory));
        updateRecordCount();
        analyzePattern();
        updateMapMarkers();
        
        // --- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¸ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ ---
        fetch(`${BACKEND_URL}/api/data`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ...rec, userId: userId })
        }).catch(error => console.error('ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¸ã®ãƒ‡ãƒ¼ã‚¿é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ:', error));
    }

    function updateRecordCount() { document.getElementById('recordCount').textContent = `ãƒ­ãƒ¼ã‚«ãƒ«è¨˜éŒ²æ•°: ${sensorHistory.length}`; }

    function classifyMovement(a) {
        if (!a || a.x === null) return { status: "ä¸æ˜" };
        const m = Math.sqrt(a.x**2 + a.y**2 + (a.z-9.8)**2);
        if (m < 0.5) return { status: "é™æ­¢" };
        if (m < 2.0) return { status: "æ­©è¡Œ" };
        if (m < 5.0) return { status: "èµ°è¡Œ" };
        return { status: "æ¿€ã—ã„é‹å‹•" };
    }
    
    function analyzePattern() {
        if (sensorHistory.length === 0) return;
        const lastRecord = sensorHistory[sensorHistory.length - 1];
        const movement = classifyMovement(lastRecord.accel);
        document.getElementById('movementPattern').innerHTML = `ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³: <span class="sensor-value">${movement.status}</span>`;
    }

    /* ---------- AIã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é€šä¿¡ ---------- */
    window.getAIAnalysis = async function() {
        if (sensorHistory.length < 5) { showStatus('AIåˆ†æã«ã¯æœ€ä½5ä»¶ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™ã€‚', 'error'); return; }
        showStatus('ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«AIåˆ†æã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...', 'info');
        document.getElementById('aiContent').innerHTML = 'ğŸ§  ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰AIãŒæ€è€ƒä¸­...';
        document.getElementById('aiAnalysisBtn').disabled = true;

        try {
            const response = await fetch(`${BACKEND_URL}/api/analyze`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ history: sensorHistory })
            });
            if (!response.ok) throw new Error(`ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼: ${response.status}`);
            const result = await response.json();
            if (result.error) throw new Error(result.error);
            document.getElementById('aiContent').innerHTML = result.analysis.replace(/\n/g, '<br>');
            showStatus('AIåˆ†æãŒå®Œäº†ã—ã¾ã—ãŸ', 'success');
            embedMapsInAnalysis();
        } catch (error) {
            document.getElementById('aiContent').innerHTML = `åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
            showStatus('AIåˆ†æã‚¨ãƒ©ãƒ¼', 'error');
        } finally {
            document.getElementById('aiAnalysisBtn').disabled = false;
        }
    }
    
    window.getSearchSuggestions = async function() {
        const currentAnalysis = document.getElementById('aiContent').innerText;
        if (currentAnalysis.includes('...')) { showStatus('ã¾ãšAIåˆ†æã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚', 'error'); return; }
        showStatus('ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ¢ç´¢ææ¡ˆã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...', 'info');
        document.getElementById('aiContent').innerHTML += '<hr>ğŸ—ºï¸ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰AIãŒãƒ«ãƒ¼ãƒˆã‚’è¨ˆç”»ä¸­...';
        document.getElementById('aiSuggestBtn').disabled = true;
        
        try {
            const response = await fetch(`${BACKEND_URL}/api/suggest`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ analysis: currentAnalysis })
            });
            if (!response.ok) throw new Error(`ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼: ${response.status}`);
            const result = await response.json();
            if (result.error) throw new Error(result.error);
            document.getElementById('aiContent').innerHTML = result.suggestion.replace(/\n/g, '<br>');
            showStatus('æ¢ç´¢ææ¡ˆãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸ', 'success');
            embedMapsInAnalysis();
        } catch (error) {
            document.getElementById('aiContent').innerHTML = `ææ¡ˆã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
            showStatus('æ¢ç´¢ææ¡ˆã‚¨ãƒ©ãƒ¼', 'error');
        } finally {
            document.getElementById('aiSuggestBtn').disabled = false;
        }
    }

    /* ---------- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° (ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãªã©) ---------- */
    window.exportCSV = function() {
        if (sensorHistory.length === 0) { showStatus('ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error'); return; }
        // â˜…â˜…â˜… å¤‰æ›´ç‚¹: ãƒ˜ãƒƒãƒ€ãƒ¼ã« bluetoothConnected ã‚’è¿½åŠ  â˜…â˜…â˜…
        const header = ['timestamp', 'ax', 'ay', 'az', 'lat', 'lng', 'accuracy', 'bluetoothConnected'];
        const rows = sensorHistory.map(r => [r.ts, r.accel.x, r.accel.y, r.accel.z, r.loc.lat, r.loc.lng, r.loc.accuracy, r.bluetoothConnected].join(','));
        downloadFile([header.join(','), ...rows].join('\n'), 'sensor_data.csv', 'text/csv');
    }

    window.exportJSON = function() {
        if (sensorHistory.length === 0) { showStatus('ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error'); return; }
        downloadFile(JSON.stringify(sensorHistory, null, 2), 'sensor_data.json', 'application/json');
    }

    function downloadFile(data, filename, type) {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename; document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    window.connectBluetoothDevice = async function() {
        try {
            const device = await navigator.bluetooth.requestDevice({
                acceptAllDevices: true
            });
            connectedDeviceName = device.name || 'åç§°ãªã—';
            deviceId = device.id || getOrCreateDeviceId();
            showStatus('Bluetoothãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶šã—ã¾ã—ãŸ: ' + connectedDeviceName, 'success');
            updateDeviceNameDisplay();
            device.addEventListener('gattserverdisconnected', () => {
                showStatus('Bluetoothãƒ‡ãƒã‚¤ã‚¹ãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚è¨ˆæ¸¬ã‚’åœæ­¢ã—ã¾ã™ã€‚', 'error');
                stopSensing();
            });
            document.getElementById('bluetoothConnectUI').style.display = 'none';
            document.getElementById('permissionRequestUI').style.display = 'block';
            if (document.getElementById('deviceIdDisplay')) {
                document.getElementById('deviceIdDisplay').textContent = `ãƒ‡ãƒã‚¤ã‚¹ID: ${deviceId}`;
            }
        } catch (error) {
            showStatus('Bluetoothæ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error, 'error');
        }
    }

    function updateDeviceNameDisplay() {
        const el = document.getElementById('deviceNameDisplay');
        if (connectedDeviceName) {
            el.textContent = `è¨ˆæ¸¬ä¸­: ${connectedDeviceName}`;
        } else {
            el.textContent = '';
        }
    }

    function resetHistory() {
        localStorage.removeItem('sensorHistory');
        localStorage.removeItem('deviceTrackerUserId');
        localStorage.removeItem('sensorPermissionGranted');
        connectedDeviceName = null;
        updateDeviceNameDisplay();
        location.reload();
    }

    window.broadcastLostDevice = async function() {
        // (ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã—)
        const deviceName = connectedDeviceName || "ä¸æ˜ãƒ‡ãƒã‚¤ã‚¹";
        const userId = getOrCreateUserId();
        const deviceIdToSend = deviceId || getOrCreateDeviceId();
        const lastRecord = sensorHistory.length > 0 ? sensorHistory[sensorHistory.length - 1] : null;

        if (!lastRecord || !lastRecord.loc) {
            showStatus("ä½ç½®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚è¨ˆæ¸¬ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚", "error");
            return;
        }

        const message = prompt("ç´›å¤±ãƒ‡ãƒã‚¤ã‚¹ã«é–¢ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚„é€£çµ¡å…ˆã‚’å…¥åŠ›ã§ãã¾ã™ï¼ˆä»»æ„ï¼‰", "");

        const payload = {
            deviceId: deviceIdToSend,
            deviceName,
            userId,
            lastKnownLocation: lastRecord.loc,
            timestamp: new Date().toISOString(),
            message: message || ""
        };

        try {
            const response = await fetch(`${BACKEND_URL}/api/broadcast`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error("ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼");
            const result = await response.json();
            showStatus(result.message || "ç´›å¤±æƒ…å ±ã‚’é€ä¿¡ã—ã¾ã—ãŸ", "success");
            await fetchAndDisplayBroadcasts();
        } catch (error) {
            showStatus("ç´›å¤±æƒ…å ±ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ: " + error.message, "error");
        }
    }

    window.manualHelpReport = function() {
        // (ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã—)
        fetch(`${BACKEND_URL}/api/broadcasts`)
            .then(res => res.json())
            .then(broadcasts => {
                if (!Array.isArray(broadcasts) || broadcasts.length === 0) {
                    showStatus('ç¾åœ¨ã€å”åŠ›ã§ãã‚‹ç´›å¤±ãƒ‡ãƒã‚¤ã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“', 'info');
                    return;
                }
                const target = broadcasts[0];
                const deviceId = target.deviceId;
                const message = prompt("å”åŠ›ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚„ç™ºè¦‹çŠ¶æ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä»»æ„ï¼‰", "");
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(async (pos) => {
                        const location = {
                            lat: pos.coords.latitude,
                            lng: pos.coords.longitude,
                            accuracy: pos.coords.accuracy
                        };
                        const payload = {
                            deviceId,
                            helperId: getOrCreateUserId(),
                            location,
                            timestamp: new Date().toISOString(),
                            message: message || ""
                        };
                        await fetch(`${BACKEND_URL}/api/help_report`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        showStatus('å”åŠ›ä½ç½®æƒ…å ±ã‚’é€ä¿¡ã—ã¾ã—ãŸ', 'success');
                        await fetchAndDisplayBroadcasts();
                    }, () => {
                        showStatus('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                    });
                }
            });
    }

    async function fetchAndDisplayBroadcasts() {
        // (ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã—)
        if (!markerGroup) return;
        markerGroup.clearLayers();

        if (sensorHistory && sensorHistory.length > 0) {
            const customIcon = L.icon({
                iconUrl: '/src/pan.png',
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32]
            });
            sensorHistory.forEach(record => {
                if (record.loc && record.loc.lat && record.loc.lng) {
                    const lat = parseFloat(record.loc.lat);
                    const lng = parseFloat(record.loc.lng);
                    L.marker([lat, lng], {icon: customIcon}).addTo(markerGroup)
                        .bindPopup(`æ™‚é–“: ${new Date(record.ts).toLocaleTimeString()}<br>çŠ¶æ…‹: ${classifyMovement(record.accel).status}`);
                }
            });
        }

        try {
            const response = await fetch(`${BACKEND_URL}/api/broadcasts`);
            if (!response.ok) {
                console.error("æ”¾é€ãƒ‡ãƒã‚¤ã‚¹å–å¾—å¤±æ•—:", response.status);
                return;
            }
            const broadcasts = await response.json();
            if (!Array.isArray(broadcasts)) return;

            for (const b of broadcasts) {
                if (b.lastKnownLocation?.lat && b.lastKnownLocation?.lng) {
                    const lat = parseFloat(b.lastKnownLocation.lat);
                    const lng = parseFloat(b.lastKnownLocation.lng);
                    const icon = L.icon({
                        iconUrl: `src/lost.png`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 32],
                        popupAnchor: [0, -32]
                    });
                    const popupContent = `
                        ğŸ“¢ <b>ç´›å¤±ãƒ‡ãƒã‚¤ã‚¹</b><br>
                        ãƒ‡ãƒã‚¤ã‚¹ID: ${b.deviceId || 'ä¸æ˜'}<br>
                        ãƒ‡ãƒã‚¤ã‚¹å: ${b.deviceName}<br>
                        ãƒ¦ãƒ¼ã‚¶ãƒ¼ID: ${b.userId}<br>
                        ç·¯åº¦: ${lat}<br>
                        çµŒåº¦: ${lng}<br>
                        æ™‚é–“: ${new Date(b.timestamp).toLocaleString()}<br>
                        <span style="color:#22543d;">${b.message ? 'ğŸ“ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ' + b.message : ''}</span>
                    `;
                    L.marker([lat, lng], { icon }).addTo(map).bindPopup(popupContent);

                    try {
                        const helpRes = await fetch(`${BACKEND_URL}/api/help_reports?deviceId=${encodeURIComponent(b.deviceId)}`);
                        const helpPoints = await helpRes.json();
                        helpPoints.forEach(h => {
                            if (h.location && h.location.lat && h.location.lng) {
                                const helpIcon = L.icon({
                                    iconUrl: 'src/pin2.png',
                                    iconSize: [24, 24],
                                    iconAnchor: [12, 24],
                                    popupAnchor: [0, -24]
                                });
                                const hlat = typeof h.location.lat === 'string' ? parseFloat(h.location.lat) : h.location.lat;
                                const hlng = typeof h.location.lng === 'string' ? parseFloat(h.location.lng) : h.location.lng;
                                L.marker([
                                    hlat,
                                    hlng
                                ], { icon: helpIcon })
                                    .addTo(map)
                                    .bindPopup(`ğŸ§­ å”åŠ›è€…: ${h.helperId}<br>ç·¯åº¦: ${h.location.lat}<br>çµŒåº¦: ${h.location.lng}<br>æ™‚é–“: ${new Date(h.timestamp).toLocaleString()}<br>${h.message ? 'ğŸ“ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ' + h.message : ''}`);
                            }
                        });
                    } catch (e) {
                        console.error('å”åŠ›ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—:', e);
                    }
                }
            }
        } catch (err) {
            console.error("ç´›å¤±æƒ…å ±ã®å–å¾—ã«å¤±æ•—:", err);
            showStatus("ç´›å¤±ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ", "error");
        }
    }

    function embedMapsInAnalysis() {
        // (ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã—)
        const aiContent = document.getElementById('aiContent');
        const content = aiContent.innerHTML;
        
        const regex = /ç·¯åº¦([+-]?\d+\.\d+)ã€çµŒåº¦([+-]?\d+\.\d+)/g;
        let result;
        let modifiedContent = content;
        let latLngData = [];
        
        while ((result = regex.exec(content)) !== null) {
            latLngData.push({
                lat: parseFloat(result[1]),
                lng: parseFloat(result[2]),
                index: result.index,
                fullMatch: result[0]
            });
        }
        
        for (let i = latLngData.length - 1; i >= 0; i--) {
            const data = latLngData[i];
            const mapId = `map-${i}`;
            const mapContainer = `<div id="${mapId}" style="width: 100%; height: 200px; margin: 10px 0; border-radius: 8px; border: 2px solid #e3e8ff;"></div>`;
            
            const insertPosition = data.index + data.fullMatch.length;
            modifiedContent = modifiedContent.slice(0, insertPosition) + 
                             '<br>' + mapContainer + 
                             modifiedContent.slice(insertPosition);
        }
        
        aiContent.innerHTML = modifiedContent;
        
        setTimeout(() => {
            latLngData.forEach((data, i) => {
                const mapId = `map-${i}`;
                const mapElement = document.getElementById(mapId);
                if (mapElement) {
                    const miniMap = L.map(mapId).setView([data.lat, data.lng], 18);
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: 'Â© OpenStreetMap contributors'
                    }).addTo(miniMap);
                    
                    L.marker([data.lat, data.lng], {
                        icon: L.icon({
                            iconUrl: '/src/pin.png',
                            iconSize: [32, 32],
                            iconAnchor: [16, 32],
                            popupAnchor: [0, -32]
                        })
                    }).addTo(miniMap).bindPopup(`æ¨å®šä½ç½® ${i + 1}: ${data.lat}, ${data.lng}`);
                }
            });
        }, 100);
    }

    window.assistSearch = async function() {
        // (ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã—)
        showStatus('å‘¨å›²ã®Bluetoothãƒ‡ãƒã‚¤ã‚¹ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 'info');
        let broadcasts = [];
        try {
            const res = await fetch(`${BACKEND_URL}/api/broadcasts`);
            broadcasts = await res.json();
        } catch (e) {
            showStatus('æ”¾é€ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±ã®å–å¾—ã«å¤±æ•—', 'error');
            return;
        }
        if (!Array.isArray(broadcasts) || broadcasts.length === 0) {
            showStatus('ç¾åœ¨ã€å”åŠ›ã§ãã‚‹ç´›å¤±ãƒ‡ãƒã‚¤ã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“', 'info');
            return;
        }
        const lostDeviceIds = broadcasts.map(b => b.deviceId).filter(Boolean);
        const lostDeviceNames = broadcasts.map(b => b.deviceName).filter(Boolean);

        try {
            const device = await navigator.bluetooth.requestDevice({
                acceptAllDevices: true
            });
            if (lostDeviceIds.includes(device.id) || lostDeviceNames.includes(device.name)) {
                showStatus(`ç™ºè¦‹: ${device.name || 'åç§°ãªã—'}ï¼ˆID: ${device.id}ï¼‰ã¯ç´›å¤±ãƒ‡ãƒã‚¤ã‚¹ã§ã™ï¼`, 'success');
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(async (pos) => {
                        const location = {
                            lat: pos.coords.latitude,
                            lng: pos.coords.longitude,
                            accuracy: pos.coords.accuracy
                        };
                        const payload = {
                            deviceId: device.id,
                            helperId: getOrCreateUserId(),
                            location,
                            timestamp: new Date().toISOString()
                        };
                        await fetch(`${BACKEND_URL}/api/help_report`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        showStatus('å”åŠ›ä½ç½®æƒ…å ±ã‚’é€ä¿¡ã—ã¾ã—ãŸ', 'success');
                    }, () => {
                        showStatus('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                    });
                }
            } else {
                showStatus(`ç™ºè¦‹ã—ãŸãƒ‡ãƒã‚¤ã‚¹ï¼ˆ${device.name || 'åç§°ãªã—'}ï¼‰ã¯ç´›å¤±ãƒªã‚¹ãƒˆã«ã‚ã‚Šã¾ã›ã‚“`, 'info');
            }
        } catch (e) {
            showStatus('Bluetoothã‚¹ã‚­ãƒ£ãƒ³ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ', 'error');
        }
    }

    /* ---------- åˆæœŸåŒ– ---------- */
    window.addEventListener('load', () => {
        showStatus('ã‚¹ãƒãƒ¼ãƒˆãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®æº–å‚™ãŒã§ãã¾ã—ãŸ', 'success');
        const saved = localStorage.getItem('sensorHistory');
        if (saved) sensorHistory = JSON.parse(saved);
        deviceId = getOrCreateDeviceId();
        initMap();
        document.getElementById('bluetoothConnectUI').style.display = 'block';
        document.getElementById('permissionRequestUI').style.display = 'none';
        document.getElementById('mainControls').style.display = 'none';
        if (!document.getElementById('deviceIdDisplay')) {
            const el = document.createElement('div');
            el.id = 'deviceIdDisplay';
            el.style.marginTop = '5px';
            el.style.fontSize = '0.8rem';
            el.style.wordBreak = 'break-all';
            el.style.color = '#334155';
            el.textContent = `ãƒ‡ãƒã‚¤ã‚¹ID: ${deviceId}`;
            const featureCards = document.getElementsByClassName('feature-card');
            if (featureCards.length > 1) {
                featureCards[1].appendChild(el);
            }
        }
    });
  </script>
</body>
</html>

</body>
</html>
